package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
)

const (
	defaultDefURL = "https://raw.githubusercontent.com/swiftlang/swift/main/include/swift/Demangling/DemangleNodes.def"
)

func main() {
	outPath := flag.String("o", filepath.Join("internal", "swiftdemangle", "nodekind_generated.go"), "output Go file")
	flag.Parse()

	resp, err := http.Get(defaultDefURL)
	if err != nil {
		panic(fmt.Errorf("failed to get default definition URL: %w", err))
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		panic(fmt.Errorf("failed to get release.json: %s", resp.Status))
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(fmt.Errorf("failed to read response body: %w", err))
	}

	entries, err := parseDef(bytes.NewReader(body))
	if err != nil {
		panic(err)
	}

	if err := writeOutput(*outPath, entries, "swiftlang/swift/main/include/swift/Demangling/DemangleNodes.def"); err != nil {
		panic(err)
	}
}

type entry struct {
	Name    string
	Context bool
}

var nodePattern = regexp.MustCompile(`^\s*(CONTEXT_NODE|NODE)\(([A-Za-z0-9_]+)\)`)

func parseDef(r io.Reader) ([]entry, error) {
	scanner := bufio.NewScanner(r)
	seen := make(map[string]entry)
	for scanner.Scan() {
		line := scanner.Text()
		matches := nodePattern.FindStringSubmatch(line)
		if len(matches) == 0 {
			continue
		}
		kind := matches[1]
		name := matches[2]
		e := seen[name]
		e.Name = name
		if kind == "CONTEXT_NODE" {
			e.Context = true
		}
		seen[name] = e
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}

	entries := make([]entry, 0, len(seen))
	for _, e := range seen {
		entries = append(entries, e)
	}
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].Name < entries[j].Name
	})
	return entries, nil
}

func writeOutput(path string, entries []entry, source string) error {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by internal/swiftdemangle/cmd/gennodes; DO NOT EDIT.\n")
	buf.WriteString("// Source: " + source + "\n\n")
	buf.WriteString("package swiftdemangle\n\n")

	buf.WriteString("const (\n")
	for _, e := range entries {
		fmt.Fprintf(&buf, "\tKind%s NodeKind = \"%s\"\n", e.Name, e.Name)
	}
	buf.WriteString(")\n\n")

	buf.WriteString("var contextNodeKinds = map[NodeKind]struct{}{\n")
	for _, e := range entries {
		if !e.Context {
			continue
		}
		fmt.Fprintf(&buf, "\tKind%s: {},\n", e.Name)
	}
	buf.WriteString("}\n")

	formatted, err := gofmtSource(buf.Bytes())
	if err != nil {
		return err
	}

	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}
	return os.WriteFile(path, formatted, 0o644)
}

func gofmtSource(src []byte) ([]byte, error) {
	cmd := execCommand("gofmt")
	cmd.Stdin = bytes.NewReader(src)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return nil, err
	}
	return out.Bytes(), nil
}

func execCommand(name string) *exec.Cmd {
	return exec.Command(name)
}
