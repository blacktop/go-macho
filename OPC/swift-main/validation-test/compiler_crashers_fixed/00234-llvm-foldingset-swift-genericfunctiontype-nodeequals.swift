// This source file is part of the Swift.org open source project
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors

// RUN: not %target-swift-frontend %s -typecheck
func k<q {
    enum k {
        func j
        var _ = j
    }
}
class x  {
    s m
    func j(m)
}
struct j<u> : r {
    func j(j: j.n) {
    }
}
enum q<v> {   let k: v
    let u: v.l
}
protocol y {
    o= p>(r: m<v>)
}
struct D : y {
    s p = Int
    func y<v k r {
    s m
}
class y<D> {
    w <r:
func j<v x: v) {
    x.k()
}
func x(j: Int = a) {
}
let k = x
protocol A {
    func c() -> String
}
class B {
    func d() -> String {
        return ""
    }
}
class C: B, A {
    override func d() -> String {
        return ""
    }
    func c() -> String {
        return ""
    }
}
func e<T where T: A, T: B>(t: T) {
    t.c()
}
struct c<d : Sequence> {
    var b: d
}
func a<d>() -> [c<d>] {
    return []
}
b
protocol c : b { func b
func f<r>() -> (r, r -> r) -> r {
   f r f.j = {
}
 {
   r) {
        s  }
}
protocol f {
   class func j()
}
class f: f{  class func j {}
protocol j {
    class func m()
}
class r: j {
    class func m() { }
}
(r() n j).p.m()
j=k n j=k
protocol r {
    class func q()
}
s m {
    m f: r.q
    func q() {
        f.q()
    }
(l, () -> ())
}
func f<l : o>(r: l)
func f<e>() -> (e, e -> e) -> e {
    e b e.c = {}
    {
        e)
        {
            f
        }
    }
    protocol f {
        class func c()
    }
    class e: f {
        class func c
    }
}
func C<D, E: A where D.C == E> {
}
func prefix(with: String) -> <T>(() -> T) -> String {
  { g in "\(withing
}
clasnintln(some(xs))
protocol A {
    func c()l k {
    func l() -> g {
        m ""
    }
}
class C: k, A {
    j func l()q c() -> g {
        m ""
    }
}
func e<r where r: A, r: k>(n: r) {
    n.c()
}
protocol A {
    typealias h
}
c k<r : A> {
    p f: r
    p p: r.h
}
protocol C      l.e()
    }
}
class o {
    typealias l = l
w
class x<u>: d {
    l i: u
    init(i: u) {
        o.i = j {
  r { w s "\(f): \(w())" }
}
protocol h {
    q k {
    t w
}
w
protocol k : w { func v <h: h m h.p == k>(l: h.p) {
    }
}
protocol h {
    n  func w(w:
}
class h<u : h> {
  }
}
class b<i : b> i: g{ func c {}
e g {
 : g {
h func i() ->  }
struct c<d: Sequence, b where Optional<b> == d.Iterator.Element>
}
class p {
    u _ = q() {
    }
}
u l = r
u s: k -> k = {
    n $h: m.j) {
    }
}
o l() {
    ({})
}
struct m<t> {
    let p: [(t, () -> ())] = []
}
protocol p : p {
}
protocol m {
    o u() -> String
}
class j {
    o m() -> String {
        n ""
    }
}
class h: j, m {
    q o m() -> String {
        n ""
    }
    o u() -> S, q> {
}
protocol u {
    typealias u
}
class p {
    typealias u = u
func a<d>() -> [c{    enum b {
        case c
1, g(f, j)))
m k {
    class h k()
}
struct i {
    i d: k.l    h k() {
      n k
}
class g {
    typealias k = k
}
class k {
    func l((Any, k))(m }
}
func j<f: l: e -> e = {
 {
   l) {
      m  }
}
protocol k {
   class func j()
}
class e: k{  class func j
func d<b: Sequence, e where Optional<e> == b.Iterator.Element>(c : b) -> e? {
    for (mx : e?) in c {
    }
}
func o() -> i) -> b {
  n { o f "\(k): \(o())" }
}
struct d<d : n, o:j n {
    l p
}
protocol o : o {
}
func o<
func i(c: () -> ()) {
}
class a {
    var _ = i() {
    }
}
() {
    g g         h g
    }
}
func e(i: d) -> <f>(() -> f)>
>(f: B<{ }
})
}
func prefix(with: ng) -> <T>(() -> T)
func b(c) -> <d>(() -> d) {
}
func f() {
    ({})
}
func j(d: h) -> <k>(() -> k) -> h {
  return { n n "\(}
c i<k : i> {
}
c i: i {
}
c e : l {
}
f = e
protocol m : o h = h
}
struct l<e : Sequence> {
    l g: e
}
func h<e>() -> [l<e>] {
    f []
}
func i(e: g) -> <j>(() -> j) -> k
func c<e>() -> (e -> e) -> e {
 e, e -> e)    n  }
}
protocol f {
   class func n()
}
class l: f{  class func n {}
func a<i>() {
    b b {
        l j
    }
}
class a<f : b, l : b m f.l == l> {
}
protocol b {
    typealias l
    typealias k
}
struct j<n : b> : b {
    typealias l = n
    typealias k = a<j<n>, l>
}
d ""
e}
class d {
    fun
