Swift Name Mangling and Demangling: A Comprehensive Overview

Swift Name Mangling is the process of encoding extra information (like module names, types, generics, etc.) into symbol names, to avoid collisions and convey function signatures in compiled binaries. Languages like C++ and Swift support function overloading and other features that require more than just the name to uniquely identify a symbol. Name mangling ensures that each symbol name in the binary is unique and unambiguous to the linker【23](https://www.mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html#L98-L106)】. For example, in C++, two functions named foo with different parameters would be mangled into distinct symbols (such as __Z3fooi vs __Z3food for foo(int) vs foo(double)), since _foo alone would collide【23](https://www.mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html#L98-L106)】. Swift, which also allows function overloading and has a rich type system, similarly requires name mangling for its symbols – the mechanism is broadly similar to C++’s but carries much more information about the types and context【22](https://www.mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html#L129-L132)】.

Demangling, conversely, is the act of decoding a mangled name back into a human-readable form (the original function or type name). Swift provides a demangler as part of its toolchain to translate those cryptic symbol names (e.g. _$s8MyModule4TestV5valueSivp) back into something developers can recognize (e.g. MyModule.Test.value : Int). This is crucial for debugging, logging, crash reports, and any scenario where you need to interpret raw symbol names.

Swift’s Name Mangling Scheme

Swift’s name mangling scheme is based on the Itanium C++ ABI mangling conventions in principle, but with extensions to support Swift-specific features【22](https://www.mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html#L129-L132)】. In practice, a Swift mangled symbol encodes a lot of information about its context:
	•	Prefixes: Swift mangled symbols traditionally begin with a special prefix. In early Swift (versions 1–3), symbols started with _T (or _TF, _TT, etc.), while newer Swift (ABI-stable Swift 5+) uses a $s or $S prefix for symbols【28](https://forums.swift.org/t/demangle-function/25416#L293-L301)】. For example, a Swift 5 symbol might look like $sModuleName… whereas older symbols began _T (the Swift runtime still recognizes both forms for backwards compatibility【28](https://forums.swift.org/t/demangle-function/25416#L293-L301)】). The prefix is immediately followed by codes indicating the symbol kind.
	•	Kind codes: After the prefix, markers denote what kind of entity the symbol represents. For instance, F can indicate a function, v a variable, etc. In one complex example, a Swift symbol included F to mark a function and C repeated multiple times to indicate nested class contexts【30](https://www.mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html#L165-L172)】. Swift encodes each level of nested type or context with specific letters.
	•	Name and type encoding: The mangled name encodes module names, class/struct names, function or property names, and types of parameters/returns. It often does this by writing the length of each identifier followed by the identifier itself. For example, in a mangled name, you might see 4test to represent the module name “test” which has 4 letters【30](https://www.mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html#L169-L172)】. Type information (like whether an argument is an Int, String, generic type, etc.) is encoded with special abbreviations or further sequences. Swift’s scheme is more elaborate than C++’s; it can represent generics, protocol conformances, extensions, etc., which go beyond what the C++ mangling needed to handle【22](https://www.mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html#L129-L132)】. For instance, a mangled name for a generic function will include info about its type parameters and constraints.
	•	Old vs New Mangling: Swift underwent a change in its mangling scheme around the time of Swift 4.2 / 5.0 when ABI stability was achieved. The newer mangling (sometimes called “mangled name v2”) is more compact and starts with $s. The Swift compiler and runtime still support demangling symbols from the older scheme (often indicated by _T0 or _T prefixes) for compatibility. In fact, the Swift codebase contains an OldDemangler alongside the current demangler to handle legacy symbols【21](https://www.cocoawithlove.com/blog/2016/05/01/swift-name-demangling.html#L40-L44)】.

As a concrete illustration, consider the Swift symbol example given in a Swift Evolution proposal for a demangle function:

Mangled: $sSS7cStringSSSPys4Int8VG_tcfC
Demangled: Swift.String.init(cString: Swift.UnsafePointer<Swift.Int8>) -> Swift.String【28](https://forums.swift.org/t/demangle-function/25416#L212-L220)】

Here we can observe the $s prefix for Swift 5, and the mangled string encodes the module (Swift), the type (String), the initializer init(cString:) with its parameter type UnsafePointer<Int8> and the return type String. The mangling scheme packs all of that into a single string. Tools like the Swift demangler or lldb can decode this back into the human-readable form as shown.

The Swift Demangler Tool and Implementation

Swift provides an official command-line tool called swift-demangle (as part of the Xcode toolchain or Swift toolchain) to demangle symbol names. Developers commonly use this for diagnosing crash logs or symbol names. For example, running swift-demangle on a mangled name will print out the demangled counterpart. By default it shows the full, verbose name including module names and type information. There is also a “simplified” mode (invoked with swift-demangle -simplified) that produces a shorter name often used by LLDB and profiling tools【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L29-L37)】. In fact, LLDB (the debugger) and Instruments will automatically display demangled names in a simplified form by default for readability【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L29-L37)】.

How it works internally: The demangling logic in Swift is implemented in the open-source Swift project, mainly in C++ source files (such as Demangler.cpp in the swift/lib/Demangling/ directory). The demangler essentially performs a recursive descent parse of the mangled string. It tokenizes the string (using a custom scanner for the characters of the symbol) and builds an abstract syntax tree (AST) of Node objects representing the components of the symbol【21](https://www.cocoawithlove.com/blog/2016/05/01/swift-name-demangling.html#L81-L89)】. Each node might be something like “Module”, “Class”, “Function”, or “Type Int”. Once the tree is built, the demangler can then render it into a human-readable string. This is exactly what the swift-demangle tool does: it calls into the demangler library to parse and then pretty-print the demangled name.

Notably, the demangler library also supports outputting different styles of demangled names through its options. It can emit the full symbol (with all modules and type parameters) or a simplified version without module names, etc. It even has the ability to output a representation of the parse tree itself (for debugging purposes). For example, if you run swift-demangle in an “expand” mode, it will show a structured tree of the symbol’s components instead of one line of text【32](https://fuchsia.googlesource.com/third_party/swift/+/refs/tags/swift-DEVELOPMENT-SNAPSHOT-2018-04-01-a/tools/swift-demangle/swift-demangle.cpp#L1-L4)】. Internally, after parsing a symbol into a NodePointer (the root of the AST), the tool can either convert it back to a string or dump the node tree depending on options【32](https://fuchsia.googlesource.com/third_party/swift/+/refs/tags/swift-DEVELOPMENT-SNAPSHOT-2018-04-01-a/tools/swift-demangle/swift-demangle.cpp#L1-L4)】. The demangler is also capable of re-mangling a node tree back into the mangled form, which is used as a consistency check – it verifies that if you demangle and then remangle a symbol, you get the same string back. In the Swift demangler implementation, after demangling a name into a node tree, there’s logic to remangle it and ensure it matches the original (helpful for testing round-trip correctness)【33](https://fuchsia.googlesource.com/third_party/swift/+/refs/tags/swift-DEVELOPMENT-SNAPSHOT-2018-04-01-a/tools/swift-demangle/swift-demangle.cpp#L99-L107)】. If a discrepancy is found, the tool will report an error. This gives an idea of how robust the demangler is designed to be.

Supported formats: The demangler recognizes both old and new mangling prefixes when parsing. In code, it handles symbol strings beginning with _T, _T0 (old scheme), as well as $S or $s (new scheme), among others【28](https://forums.swift.org/t/demangle-function/25416#L293-L301)】. This means it can demangle symbols produced by modern Swift compilers and those from older Swift versions (important when analyzing libraries compiled with older Swift).

In summary, swift-demangle is a reliable tool to turn mangled gibberish into intelligible Swift signatures. Under the hood, it uses the Swift runtime’s demangling library which can be thought of as a specialized parser and pretty-printer for Swift symbol names.

Programmatic Demangling in Swift

While the command-line tool is handy, developers have sometimes wanted to demangle names within their Swift programs (for example, to log human-readable names for types or symbols at runtime). As of 2025, there is no public official API in the Swift standard library for demangling arbitrary strings, but there are ways to achieve it:
	•	Using the runtime function: Swift’s runtime provides a C function swift_demangle which the tool itself uses. This function is not officially documented for public use (and not directly exported to Swift), but it can be invoked via the C ABI. For instance, on Apple platforms one can use dlsym to retrieve the swift_demangle symbol and call it. The function signature (as inferred) is: char *swift_demangle(const char *mangledName, size_t mangledNameLength, char *outputBuffer, size_t *outputBufferSize, uint32_t flags)【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L115-L123)】. It returns a heap-allocated C-string with the demangled result (or requires the caller to provide a buffer). In Swift 5 and above, this approach is used in some Stack Overflow examples where they define a function pointer to swift_demangle and call it to get a Swift string result【34](https://stackoverflow.com/questions/24321773/how-can-i-demangle-a-swift-class-name-dynamically#L1-L4)】. For example, one can import Darwin (or GLibc on Linux) and use unsafeBitCast with dlsym to call swift_demangle【34](https://stackoverflow.com/questions/24321773/how-can-i-demangle-a-swift-class-name-dynamically#L1-L4)】. This is effectively tapping into the same logic that swift-demangle uses, just from within a Swift process. (Note: This is considered unofficial and may not be future-proof, but it has been known to work and is even mentioned by Swift developers as the underlying mechanism【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L115-L123)】.)
	•	CwlDemangle: An easier and safer route is to use a community-provided library. One notable example is Matt Gallagher’s CwlDemangle – a single-file Swift library that is a reimplementation of Swift’s Demangler in Swift code【21](https://www.cocoawithlove.com/blog/2016/05/01/swift-name-demangling.html#L12-L18)】. This was created as a proof of concept and for comparing Swift vs C++ performance, but it turns out to be practically useful. Developers have reported success using CwlDemangle to get demangled names at runtime【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L83-L90)】. Since it’s pure Swift, one can include that file in a project and call a function to demangle strings without dealing with unsafe pointers.
	•	Swift Evolution proposal (SE-0262): There was an official initiative to add a demangle function to the Swift Standard Library. Proposal SE-0262 pitched a standard library function demangle(_ mangledName: String) -> String? (and a variant that writes to a buffer) to make demangling easier for developers【28](https://forums.swift.org/t/demangle-function/25416#L230-L239)】. The motivation was exactly that many rely on launching the external swift-demangle tool or hacks, which is awkward if you want to do it in-process【28](https://forums.swift.org/t/demangle-function/25416#L219-L227)】. The review of this proposal was conducted in 2019. Ultimately, the Swift core team did not accept it as-is and returned it for revision, citing a few concerns【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L11-L19)】:
	•	The initial design included an “unsafe” buffer variant intended for use in low-level contexts (like signal handlers or crash contexts where allocating memory is risky). The core team noted that the current demangler isn’t actually safe for such contexts because it does allocate internally while parsing, so presenting an API that implied it could be used in a crash handler was misleading【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L17-L25)】. They suggested dropping that variant and just providing the simple String -> String? version.
	•	They also wanted the API to clarify what form of demangled output it produces (full vs simplified) and perhaps allow selecting one. The suggestion was that both full and simplified outputs should be supported【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L29-L37)】, as different use cases might prefer one or the other.
	•	There was discussion of whether such a function belongs in the standard library at all, or if it should live in a separate “Runtime” module for debug/reflective utilities【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L35-L43)】 (to avoid polluting the standard lib namespace with a niche function). The core team was open to adding it (they agreed the functionality is very useful), but these design questions needed to be resolved.
As of the latest updates (through 2022), this proposal had not been revised or accepted yet【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L73-L81)】. A member of the core team noted that if developers need a demangler immediately, they can link against the existing libswiftDemangle from the Swift open-source project or use existing solutions【29](https://forums.swift.org/t/returned-for-revision-se-0262-demangle-function/28186#L73-L81)】. This means that, for now, most developers rely on either the private runtime function or third-party libraries like CwlDemangle (or simply call out to the swift-demangle tool as a subprocess).

Conclusion

In summary, Swift’s name mangling is a crucial mechanism that allows the language to support advanced features by encoding rich type information into symbol names. The flip side is that these symbol names are unreadable to humans, which is where Swift’s demangler comes into play. The Swift project provides a robust demangling implementation (also available via the swift-demangle tool) that can translate mangled names back to a human-friendly form. This is invaluable for debugging and tooling. While an official high-level API for demangling in code is still pending, developers have found ways to demangle programmatically using the underlying C function【34](https://stackoverflow.com/questions/24321773/how-can-i-demangle-a-swift-class-name-dynamically#L1-L4)】 or community libraries. The state-of-the-art as of 2025 is that we expect Swift to eventually offer a formal API (possibly once details around usage in no-allocation contexts and module placement are sorted out), but until then, the existing tools and methods fill the gap.

All these details highlight the balance Swift’s design strikes between compiler/linker needs and developer experience: the compiler generates complex symbol names for correctness and performance, and complementary tooling like the demangler ensures developers can still work at the level of understandable Swift identifiers when diagnosing issues. Swift’s approach to name mangling continues to evolve, but it remains a fascinating aspect of the language’s runtime and binary interface, connecting the human-readable world of Swift source code with the lower-level world of binaries and memory addresses.

## Swift Upstream References

We rely on the upstream Swift sources at `OPC/swift-main/` to understand the full parser surface area, node definitions, and formatting rules before extending the pure-Go demangler. Review these before touching the parser:

**Headers / Source**
- `include/swift/AST/ASTDemangler.h`
- `include/swift/Demangling/Demangle.h`
- `include/swift/Demangling/DemangleNodes.def`
- `include/swift/Demangling/Demangler.h`
- `include/swift/SwiftDemangle/SwiftDemangle.h`
- `lib/AST/ASTDemangler.cpp`
- `lib/Demangling/Demangler.cpp`
- `lib/Demangling/DemanglerAssert.h`
- `lib/Demangling/OldDemangler.cpp`
- `lib/SwiftDemangle/SwiftDemangle.cpp`
- `stdlib/public/runtime/Demangle.cpp`

**Tests / Fixtures**
- `test/Demangle/`
- `test/SourceKit/Demangle/`
- `unittests/Basic/DemangleTest.cpp`
- `unittests/SwiftDemangle/`
- `unittests/SwiftDemangle/DemangleTest.cpp`

**What to capture while reading**
1. Node kinds and payloads from `DemangleNodes.def`, mapping directly to `internal/swiftdemangle/node.go`.
2. Formatting helpers in `ASTDemangler.cpp`/`SwiftDemangle.cpp` (async/throws ordering, descriptor print logic, simplified output rules).
3. Legacy `_T` handling paths (`OldDemangler.cpp`) and symbolic-reference resolution logic.
4. High-value test symbols from `test/Demangle` to recreate in our parity/round-trip suites.

**Gap snapshot (Oct 25 2025)**
- Upstream declares ~370 node kinds in `DemangleNodes.def`; our Go AST models ~30. Plan: add a `.def`-driven generator (similar to `types/swift`) so `internal/swiftdemangle` stays in sync with upstream additions without manual edits.
- Formatting parity currently diverges on method/property descriptors, async/throws suffixes, and ObjC bridge symbols. Relevant reference code: `ASTDemangler.cpp::printFunction`, `SwiftDemangle.cpp::DemanglerPrinter`, descriptor helpers.
- Legacy `_T` manglings beyond basic tuples aren’t parsed yet—follow `OldDemangler.cpp` branches to cover them before we invest in new symbol kinds.

---

### 2025-10-26 updates

- Implemented Swift’s word-substituted identifier grammar (`0…` form) in the parser so private identifiers such as `_ObjectiveCType` now materialize by replaying the shared word table just like `Demangler::demangleIdentifier`.
- Added support for the modified punycode mode (`00…`) by translating `_` back to `-`, mapping `A…J` to digits, and running the reconstructed label through `idna.Lookup` (with an `xn--` prefix) so non-ASCII identifiers work without CGO.
- `tryParseDependentAssocElement` now parses the associated-type name before consuming the trailing `Q{z|y…}` opcode, allowing us to emit `KindDependentMemberType` nodes that mirror Swift’s `Demangler::demangleArchetype` (e.g., `A._ObjectiveCType`).
