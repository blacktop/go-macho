package main

import (
	"bufio"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"time"
)

const (
	standardTypesURL    = "https://raw.githubusercontent.com/swiftlang/swift/main/include/swift/Demangling/StandardTypesMangling.def"
	standardTypesOut    = "types/swift/standard_types_generated.go"
	standardTypesSource = "swiftlang/swift/main/include/swift/Demangling/StandardTypesMangling.def"
)

type category int

const (
	categoryStandard category = iota
	categoryConcurrency
)

type entry struct {
	mangling string
	typeName string
	cat      category
}

var (
	stdRegex         = regexp.MustCompile(`^STANDARD_TYPE\(\s*[^,]+,\s*([^,]+),\s*([^)]+)\)`)
	concurrencyRegex = regexp.MustCompile(`^STANDARD_TYPE_CONCURRENCY\(\s*[^,]+,\s*([^,]+),\s*([^)]+)\)`)
	objcRegex        = regexp.MustCompile(`^OBJC_INTEROP_STANDARD_TYPE\(\s*[^,]+,\s*([^,]+),\s*([^)]+)\)`)
)

func main() {
	resp, err := http.Get(standardTypesURL)
	if err != nil {
		fatal(fmt.Errorf("failed to GET %s: %w", standardTypesURL, err))
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		fatal(fmt.Errorf("unexpected status %s fetching %s", resp.Status, standardTypesURL))
	}

	entries, err := parseEntries(resp.Body)
	if err != nil {
		fatal(err)
	}

	if err := writeOutput(entries, standardTypesOut, standardTypesSource); err != nil {
		fatal(err)
	}
}

func fatal(err error) {
	fmt.Fprintf(os.Stderr, "genstandardtypes: %v\n", err)
	os.Exit(1)
}

func parseEntries(r io.Reader) ([]entry, error) {
	var entries []entry
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "//") || strings.HasPrefix(line, "#") {
			continue
		}

		switch {
		case stdRegex.MatchString(line):
			matches := stdRegex.FindStringSubmatch(line)
			if len(matches) < 3 || matches[1] == "MANGLING" {
				continue
			}
			entries = append(entries, entry{
				mangling: matches[1],
				typeName: matches[2],
				cat:      categoryStandard,
			})
		case objcRegex.MatchString(line):
			matches := objcRegex.FindStringSubmatch(line)
			if len(matches) < 3 || matches[1] == "MANGLING" {
				continue
			}
			entries = append(entries, entry{
				mangling: matches[1],
				typeName: matches[2],
				cat:      categoryStandard,
			})
		case concurrencyRegex.MatchString(line):
			matches := concurrencyRegex.FindStringSubmatch(line)
			if len(matches) < 3 || matches[1] == "MANGLING" {
				continue
			}
			entries = append(entries, entry{
				mangling: matches[1],
				typeName: matches[2],
				cat:      categoryConcurrency,
			})
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return entries, nil
}

func writeOutput(entries []entry, outFile, source string) error {
	var (
		standard    = make(map[string]string)
		concurrency = make(map[string]string)
	)

	for _, e := range entries {
		fullName := "Swift." + e.typeName
		switch e.cat {
		case categoryStandard:
			standard[e.mangling] = fullName
		case categoryConcurrency:
			concurrency[e.mangling] = fullName
		}
	}

	var builder strings.Builder
	dateStamp := time.Now().UTC().Format("2006-01-02")
	builder.WriteString("// Code generated by types/swift/cmd/genstandardtypes; DO NOT EDIT.\n")
	if source != "" {
		builder.WriteString("// Source: " + source + "\n")
	}
	builder.WriteString("// Generated: " + dateStamp + "\n")
	builder.WriteString("package swift\n\n")

	writeMap := func(varName string, data map[string]string) {
		keys := make([]string, 0, len(data))
		for k := range data {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		builder.WriteString(fmt.Sprintf("var %s = map[string]string{\n", varName))
		for _, k := range keys {
			builder.WriteString(fmt.Sprintf("\t%q: %q,\n", k, data[k]))
		}
		builder.WriteString("}\n\n")
	}

	writeMap("MangledKnownTypeKind", standard)
	writeMap("MangledKnownTypeKind2", concurrency)

	dir := filepath.Dir(outFile)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return err
		}
	}

	return os.WriteFile(outFile, []byte(builder.String()), 0o644)
}
