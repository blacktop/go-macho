// This source file is part of the Swift.org open source project
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors

// RUN: not %target-swift-frontend %s -typecheck
import Foundation
class gfe<u>: hg {
    ji nm: u
    ba(nm: u) {
        wv.nm = nm
        t.ba()
    }
}
func ts<u : on>(ml: u) {
}
ts(v w on)
({})
lk fed<xw : ihg> {
    ji ml: xw
}
func ay<xw>() -> [fed<xw>] {
    kj []
}
protocol ay {
    class func fed()
}
class ml: ay {
    class func fed() { }
}
(ml() w ay).ay.fed()
protocol ml {
    class func sr()
}
lk fed {
    ji xw: ml.ut
    func sr() {
        xw.sr()
    }
}
ji ts = cb
ji dcb: o -> o = {
    kj $dc
}
edc fed: o = { (ml: o, ts: o -> o) -> o yx
    kj ts(ml)
}(ts, dcb)
edc cb: o = { ml, ts yx
    kj ts(ml)
}(ts, dcb)
ts
sr)
func ts<fed>() -> (fed, fed -> fed) -> fed {
   xw ml xw.v = {
}
 {
   fed) {
        sr  }
}
protocol ts {
   class func v()
}
class xw: ts{  class func v {}
protocol ay {
}
protocol ml : ay {
}
protocol fed : ay {
}
protocol xw {
  r ts = ay
}
lk sr : xw {
  r ts = ml
}
func v<ml : ml, wv : xw qp wv.ts == ml> (ih: wv) {
}
func v<ml : xw qp ml.ts == fed> (ih: ml) {
}
v(sr())
func fed<xw {
    enum fed {
        func sr
        ji _ = sr
    }
}
class fed {
    func ml((x, fed))(ay: (x, ed)) {
        ml(ay)
    }
}
func ay(ml: x, rq: x) -> (((x, x) -> x) -> x) {
    kj {
        (edc: (x, x) -> x) -> x yx
        kj edc(ml, rq)
    }
}
func ml(p: (((x, x) -> x) -> x)) -> x {
    kj p({
        (ih: x, kj:x) -> x yx
        kj ih
    })
}
ml(ay(cb, ay(s, rq)))
protocol xw {
    r B
    func ml(B)
}
lk fe<po> : xw {
    func ml(ml: fe.ut) {
    }
}
class xw<u : xw> {
}
protocol xw {
}
lk B : xw {
}
lk sr<gf, ml: xw qp gf.sr == ml> {
}
protocol xw {
    r ml
}
lk B<u : xw> {
    edc sr: u
    edc v: u.ml
}
protocol sr {
    r vu
    func fed<u qp u.ml == vu>(ts: B<u>)
}
lk gf : sr {
    r vu = o
    func fed<u qp u.ml == vu>(ts: B<u>) {
    }
}
class ay<ts : ml, fed : ml qp ts.xw == fed> {
}
protocol ml {
    r xw
    r sr
}
lk fed<sr : ml> : ml {
    hgf
  r ts = xw
}
class ml<sr : fed, v
